MODULE qTest;
IMPORT SYSTEM, Oberon, Files, Fonts, Display, XYplane, T :=qTypes, Lib :=qLib, X :=qOberonX;



(* ================================================== *)
(* :chapter: STANDARD PROCEDURES TO BE IMPORTED IN OTHER MODULES *)
PROCEDURE LF;   BEGIN Lib.LF      END LF;
PROCEDURE lf;   BEGIN Lib.Lf      END lf;
PROCEDURE lff;    BEGIN Lib.Lff  END lff;
PROCEDURE spc;  BEGIN Lib.Spc  END spc;
PROCEDURE ddx; BEGIN Lib.DDX   END ddx;

PROCEDURE cprint (c: CHAR); BEGIN Lib.Char (c)  END cprint;
PROCEDURE iprint (n, w: T.Int); BEGIN Lib.PrintInt (n,w) END iprint;
PROCEDURE vprint (name: ARRAY OF CHAR; n: T.Int); BEGIN Lib.ValPrint (name,n) END vprint;
PROCEDURE bprint (b: BOOLEAN); BEGIN Lib.Bool (b) END bprint;

PROCEDURE print (mess: ARRAY OF CHAR); BEGIN Lib.Print (mess) END print;
PROCEDURE chapter (mess: ARRAY OF CHAR); BEGIN Lib.Chapter (mess)  END chapter;
PROCEDURE section (mess: ARRAY OF CHAR); BEGIN Lib.Section (mess)  END section;

(* ================================================== *)
PROCEDURE TestOberonX;
VAR a, b, c: T.String;
   l: T.Line;
   ad, bd: X.DynArray;
   i: T.Int;
   l1, l2, l3: T.Line;
BEGIN
   a := "This is a string!";
    NEW (l, 128);
    COPY ("This is an other string?", l^);
   lf; print (a); print ("=>"); a := X.Upcase (a); print (a);
   lf; print (l^); print ("=>"); l := X.UpcaseLine (l); print (l^);
   lf; NEW (ad, 32); ad[0] := "a"; ad[1] := "s"; ad[2] := "d"; ad[3] := 0X;  print ("=>"); bd := X.UpcaseDynArray (ad); 
   lf; i := 0; WHILE ad[i] # 0X DO cprint (ad[i] ); INC (i) END;
   lf; i := 0; WHILE bd[i] # 0X DO cprint (bd[i] ); INC (i) END;
   lf; X.Bar (7);
   lf; print ("add:  ");  X.AddCmd;
   lf; NEW (l1, 32); NEW (l2, 32); COPY ("Hallo ", l1^);  COPY ("World!", l2);  print (l1^); print (l2^);  
      l3 := l1 + l2; print ("=>"); print (l3^);
   lf; COPY ("This is a string. ", a); COPY ("And a line of text. ", b); print (a); print (a); print ("=>");
   c := a + b; print (c); print ("]");
END TestOberonX;
(* ================================================== *)
PROCEDURE OpenTrack*;
BEGIN
   lf; print ("--- OpenTrack");
   (* no good:   Oberon.OpenTrack (2000, 200);  *)
   lf; print ("--- done");
END OpenTrack;

(* ================================================== *)
PROCEDURE TestDisplay*;
BEGIN
   lf; print ("---  TestDisplay");
   lf; vprint ("Bottom", Display.Bottom);
   lf; vprint ("Height", Display.Height);  vprint ("Width", Display.Width);
   lf; vprint ("Left", Display.Left);  vprint ("UBottom", Display.UBottom);
   lf;vprint ("ColLeft", Display.ColLeft);
   lf;print ("---  done");
   lf;
END TestDisplay;

(* ================================================== *)
PROCEDURE Cat*;
CONST Filename = "qPlaintext.txt";
VAR
   a: ARRAY 8096 OF CHAR;
   fd: Files.File;
   rd: Files.Rider;
   len, i: T.Int;
   x: SYSTEM.BYTE;
   c: CHAR;
BEGIN
   lf; print ("---  cat: "); print (Filename);  spc;
    fd := Files.Old (Filename);
   IF fd # NIL THEN
      len := Files.Length (fd);
      print ("len="); iprint (len, 0); 
      Files.Set (rd, fd, 0);
      i := 0;
      lf;
      WHILE i < len DO
         Files.Read (rd, x);
         c :=CHR (x);
         cprint (c);
         INC (i);
      END;
      print ("---  #"); lf;
      Files.Close (fd);
   ELSE print ("fd is NIL (no such file)")
   END;
   lf; 
END Cat;


(* ================================================== *)   
(* guess: byte 3 to 6 of file hold header length  
    hope: header is no longer than 256 * 256 bytes
   * --> find byte 3, skip to header, write the rest
   * translate 0D to 0A
   * translate tab to spaces
   * append 1 trailing 0A
*)
PROCEDURE DodoExport (rdIn, rdOut: Files.Rider; len: T.Int): BOOLEAN;
CONST 
   TabSize = 3;
VAR 
   cnt, headerLength, i: T.Int;
   x,y: SYSTEM.BYTE;
   c: CHAR;   
   res: BOOLEAN;
BEGIN
   print ("  [");
   IF len >= 3 THEN
      Files.Read (rdIn, x);
      Files.Read (rdIn, x);
      Files.Read (rdIn, x);
      Files.Read (rdIn, y);
      headerLength := ORD (y) * 256 + ORD (x);
      iprint (headerLength, 0); print ("header, ");
      FOR i := 4 TO headerLength - 1 DO
         Files.Read (rdIn, x);
      END;
      cnt :=0;
      WHILE ~rdIn.eof DO
         Files.Read (rdIn, x);
         IF ~rdIn.eof THEN
            c := CHR (x);
            IF c = 0DX THEN Files.Write (rdOut, 0AX); INC (cnt)
            ELSIF c = 09X THEN FOR i := 1 TO TabSize DO Files.Write (rdOut, 20X); INC (cnt) END
            ELSE Files.Write (rdOut, x); INC (cnt)
            END;
         END;
      END;
      Files.Write (rdOut, 0AX);
      INC (cnt);
      iprint (cnt, 0); print ("bytes written");
      res := TRUE;
   ELSE print ("File too short."); res :=FALSE
   END;
   print ("]");
   RETURN res;
END DodoExport;

PROCEDURE DoExport (obiname, unixname: ARRAY OF CHAR);
VAR
   fdIn, fdOut: Files.File;
   rdIn, rdOut: Files.Rider;
   len: T.Int;
   res: BOOLEAN;
BEGIN
   lf; print ("   "); 
   fdIn :=Files.Old (obiname);
   IF fdIn # NIL THEN
      Files.Set (rdIn, fdIn, 0);
      len :=Files.Length (fdIn); 
      print (obiname); spc;iprint (len, 0); print ("bytes  "); print ("=> ");print (unixname);
      fdOut := Files.New (unixname);
      IF fdOut # NIL THEN
         Files.Set (rdOut, fdOut, 0);
          res := DodoExport (rdIn, rdOut, len);
         Files.Register (fdOut);
         Files.Close (fdOut);
         IF res THEN print (" OK")
         ELSE print (" FAILED")
         END;
      ELSE print ("file 'New' failed: "); print (unixname);
      END;
      Files.Close (fdIn);
   ELSE print ("###  No such infile: "); print (obiname);
   END;
END DoExport;

PROCEDURE Export*;
BEGIN
   lf; print ("---  Export: ");
   DoExport ("qNotes.Txt" ,  "qNotes.Txt.plain.txt");

   DoExport ("qTest.Mod",          "qTest.Mod.plain.txt");
   DoExport ("qTypes.Mod",        "qTypes.Mod.plain.txt");
   DoExport ("qOberonX.Mod",   "qOberonX.Mod.plain.txt");
   DoExport ("qLib.Mod",           "qLib.Mod.plain.txt");

   lf; print ("---  done");
   lf;
END Export;

(* ================================================== *)
PROCEDURE ShowC (name: ARRAY OF CHAR);
VAR
   dx, x, y, w, h: INTEGER;
   pat: LONGINT;
   ch: CHAR;
   F: Fonts.Font;
BEGIN
   F := Fonts.This (name);
   ch := "H";
   Fonts.GetChar (F, ch, dx, x, y, w, h, pat);
   lf; cprint (ch); spc; spc; vprint ("dx",dx);  spc; vprint ("x",x); vprint ("y",y); spc; vprint ("w",w); vprint ("h",h);
   lf; print (name); print (":  "); vprint ("heigth", F.height); vprint ("minX", F.minX); vprint ("maxX", F.maxX); vprint ("minY", F.minY); vprint ("maxY", F.maxY);
END ShowC;

PROCEDURE AboutFonts*;
CONST 
   (* FontName = "Courier12.Scn.Fnt";  *)
   FontName = "Oberon20.Scn.Fnt";
BEGIN
   lf; print ("---  AboutFonts");     
   ShowC (FontName);
   lf;print ("---  done");
   lf;
END AboutFonts;


(* ================================================== *)
PROCEDURE Test*;
VAR b: BOOLEAN;
BEGIN
   LF;
   chapter ("qTest.Test");
   Lib.ResetTestCnt;
   Lib.Test (0, 7,7,"seven");
   Lib.Test (0, 120, 100 + 20, "add");
   Lib.Test (0, 122, 100 + 20, "add");
   Lib.Test (0, 124, 100 + 20, "add");
   Lib.Test (0, 125, 100 + 20 + 5, "add");
   Lib.Test (0, 129, 100 + 20 + 9, "add");
    TestOberonX;
   Lib.PrintTestCnt;
   lf; print ("--##--  time: "); iprint (Oberon.Time(), 0);
END Test;

(* ================================================== *)
PROCEDURE Draw*;
VAR
   i,j: INTEGER;
BEGIN
   lf; print ("--- qTest.Draw  ");
   XYplane.Open;
   XYplane.Clear;
   FOR i := 0 TO 100 DO
      FOR j :=0 TO 100 DO
         XYplane.Dot (i, j, 1);
      END
   END
END Draw;

(* ================================================== *)
BEGIN

(* ================================================== *)
END qTest.   
:file: 2025-Jan sts-q
